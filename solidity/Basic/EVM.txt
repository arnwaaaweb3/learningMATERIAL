===========================
# EVM (Ethereum Virtual Machine)
===========================
# In this note, we will explore all about EVM and its usecases.

Let's talk about the EVM
    To make it simple, EVM is a virtual computer machine that executes the Ethereum's smart contract.
    Imagine that EVM is a "super standard computer" that runs in every Ethereum's node.
    These nodes are executing the same instructions, same rules, to make the result identical.

So, what does EVM do?
    There's three main function that EVM does:
        1. EVM runs the bytecode of the smart contract.
            Solidity compiled the smart contract into bytecode
            Then, EVM reads and executes the bytecode like a computer.
            And here, every instruction in EVM are required gas fee.
            So, to be short, EVM is the CPU for the blockchain.
        2. Managing storage.
            All variables in smart contract like (mapping, uint, int, string, etc) are saved in:
                - Storage: This is permanent and expensive.
                - Memory: This is temporary and cheap.
                - Stack: This is the name of stacked LIFO data 
            EVM here is the mastermind behind all of these layouts
        3. Gas fees.
            Every instruction in EVM costs a gas fee.
            For example:
                   add --> cheap gas fees
                   sstore (write to storage) --> expensive gas fees
                   kkecak256 --> kinda expensive
                   etc.
        
How does EVM work? (Step-by-step)
    Imagine you're calling the "transfer()" in ERC-20 smart contract.
        1. You're sending some amount of tokens to someone (transfer).
             Here, you're calling the "transfer()" function in ERC-20 smart contract.
             The Wallet is building the transaction and sending it to the node.
                The transaction could be including the following information:
                    - from: the address of the sender
                    - to: the address of the receiver
                    - value: the amount of tokens to be sent
                    - data: the data to be executed in the smart contract
                            data is like the set of instructions / bytecode that explain what function to be executed.
                            We use 'data' to explain what function we want to execute to EVM as a bytecode.
                                For example:
                                data = 0xa9059cbb000000000000000000000000BEEF...00000000000000000000000000000000056BC75E2D63100000
                                                this means that we want to execute 'transfer(address,uint256)' function
                                Formula: data = function selector + encoded parameters
                                Solidity compiler will always have the same format of data, which means:
                                    0xa9059cbb = transfer(address,uint256)
                                

                    - gas: the gas fees to be paid
                    - gasPrice: the price of gas fees
                    - gasLimit: the maximum amount of gas to be used
                    - nonce: the number of transactions sent by the sender
                    - chainId: the chain ID of the network
                    - value: the amount of ETH to be sent
                            value is the amount of money (ETH) to be sent to the receiver.
                            this used if you want to transfer some ETH to the receiver, or if you want to pay a  smart contract some ETH to do something.
                        Example:
                        {
                            nonce: 12,
                            gasLimit: 21000,
                            maxFeePerGas: 40 gwei,
                            to: "0xABC...",
                            value: 1 ETH,
                            data: 0x... (abi encoded)
                        }
        2.Signing & Broadcasting
            Once the transaction object is created, Here's what gonna happen:         
            - Signing: 
                Your wallet (Metamask/Rabby) uses your Private Key to sign this transaction. 
                This proves that YOU (the owner of the address) authorized this specific action.             - Broadcasting: The signed transaction is sent to the "Mempool" (Memory Pool). Think of this as a waiting room for pending transactions.             - Validation: A Validator (or Miner) picks your transaction from the Mempool, verifies the signature, and includes it in the next Block.